# HTTP 的缺点

HTTP 主要不足：

-  通信使用明文（不加密），内容可能会被窃听
- 不验证通信方的身份，因此有可能遭遇伪装
- 无法证明报文的完整性，所以有可能已遭篡改

## 通信使用明文可能会被窃听  

互联网上的任何角落都存在通信内容被窃听的风险：

![](./img/wiretap.png)

防止窃听保护信息的几种对策中，最为普及的就是加密技术。加密的对象可以有：

- 通信的加密
- 内容的加密

### 通信的加密

HTTP 协议中没有加密机制，但可以通过和 SSL（ Secure Socket Layer，安全套接层）或 TLS（ Transport Layer Security，安全层传输协议）的组合使用，加密 HTTP 的通信内容。  

用 SSL 建立安全通信线路之后，就可以在这条线路上进行 HTTP 通信了。与 SSL 组合使用的 HTTP 被称为 HTTPS（ HTTP Secure，超文本传输安全协议）或 HTTP over SSL。  

![](./img/http_over_ssl.png)

### 内容的加密

即把 HTTP 报文里所含的内容进行加密处理。  

![](./img/encryped_content.png)

为了做到有效的内容加密，前提是要求客户端和服务器同时具备加密和解密机制。 主要应用在 Web 服务中。有一点必须引起注意，由于该方式不同于 SSL 或 TLS 将整个通信线路加密处理，所以内容仍有被篡改的风险。  

## 不验证通信方的身份就可能遭遇伪装  

HTTP 协议中的请求和响应不会对通信方进行确认。也就是说存在“服务器是否就是发送请求中 URI 真正指定的主机，返回的响应是否真的返回到实际提出请求的客户端”等类似问题。  

### 任何人都可发起请求  

在 HTTP 协议通信时，由于不存在确认通信方的处理步骤，任何人都可以发起请求。 另外，服务器只要接收到请求，不管对方是谁都会返回一个响应（但也仅限于发送端的 IP 地址和端口号没有被 Web 服务器设定限制访问的前提下）。  

![](./img/anyone_request.png)

- 无法确定请求发送至目标的 Web 服务器是否是按真实意图返回响应的那台服务器。有可能是已伪装的 Web 服务器
- 无法确定响应返回到的客户端是否是按真实意图接收响应的那个客户端。有可能是已伪装的客户端
- 无法确定正在通信的对方是否具备访问权限。因为某些 Web 服务器上保存着重要的信息，只想发给特定用户通信的权限  
- 无法判定请求是来自何方、出自谁手
- 即使是无意义的请求也会照单全收。无法阻止海量请求下的 DoS 攻击（Denial of Service，拒绝服务攻击）  

### 查明对手的证书

虽然使用 HTTP 协议无法确定通信方，但如果使用 SSL 则可以。SSL 不仅提供加密处理， 而且还使用了一种被称为证书的手段，可用于确定方。  

证书由值得信任的第三方机构颁发， 用以证明服务器和客户端是实际存在的。  

![](./img/certificate.png)

## 无法证明报文完整性，可能已遭篡改  

所谓完整性是指信息的准确度。若无法证明其完整性，通常也就意味着无法判断信息是否准确。  

### 接收到的内容可能有误  

没有任何办法确认，发出的请求/响应和接收到的请求/响应是前后相同的。  

![](./img/changed.png)

像这样，请求或响应在传输途中，遭攻击者拦截并篡改内容的攻击称为中间人攻击（ Man-in-the-Middle attack， MITM）。  

![](./img/mitm.png)

### 如何防止篡改  

虽然有使用 HTTP 协议确定报文完整性的方法，但并不便捷、可靠。其中常用的是 MD5 和 SHA-1 等散列值校验的方法，以及用来确认文件的数字签名方法。  

# HTTP+ 加密 + 认证 + 完整性保护 =HTTPS  

## HTTP 加上加密处理和认证以及完整性保护后即是 HTTPS  

把添加了加密及认证机制的 HTTP 称为 HTTPS（ HTTP Secure）。  

![](./img/http_secure.png)

## HTTPS 是身披 SSL 外壳的 HTTP  

HTTPS 并非是应用层的一种新协议。只是 HTTP 通信接口部分用 SSL（ Secure Socket Layer）和 TLS（ Transport Layer Security）协议代替而已。  

![](./img/https.png)

在采用 SSL 后， HTTP 就拥有了 HTTPS 的加密、证书和完整性保护这些功能。  

SSL 是独立于 HTTP 的协议，所以不光是 HTTP 协议，其他运行在应用层的 SMTP 和 Telnet 等协议均可配合 SSL 协议使用。  

## 相互交换密钥的公开密钥加密技术

SSL 采用一种叫做公开密钥加密（ Public-key cryptography）的加密处理方式。近代的加密方法中加密算法是公开的， 而密钥却是保密的。通过这
种方式得以保持加密方法的安全性。

加密和解密都会用到密钥。 没有密钥就无法对密码解密，反过来说，任何人只要持有密钥就能解密了。 如果密钥被攻击者获得，那加密也就失去了意义。  

### 共享密钥加密的困境  

加密和解密同用一个密钥的方式称为共享密钥加密（ Common key crypto system），也被叫做对称密钥加密。  

以共享密钥方式加密时必须将密钥也发给对方。  在互联网上转发密钥时，如果通信被监听那么密钥就可会落入攻击者之手， 同时也就失去了加密的意义。另外还得设法安全地保管接收到的密钥。  

![](./img/symmetric_encryption.png)

### 使用两把密钥的公开密钥加密  

公开密钥加密使用一对非对称的密钥。 一把叫做私有密钥（ privatekey），另一把叫做公开密钥（ public key）。私有密钥不能让其他任何人知道，而公开密钥则可以随意发布，任何人都可以获得。  

使用公开密钥加密方式， 发送密文的一方使用对方的公开密钥进行加密处理，对方收到被加密的信息后，再使用自己的私有密钥进行解密。 利用这种方式， 不需要发送用来解密的私有密钥，也不必担心密钥被攻击者窃听而盗走。  

要想根据密文和公开密钥，恢复到信息原文是异常困难的，因为解密过程就是在对离散对数进行求值， 这并非轻而易举就能办到。退一步讲，如果能对一个非常大的整数做到快速地因式分解，那么密码破解还是存在希望的。但就目前的技术来看是不太现实的。  

![](./img/public_private_key.png)

### HTTPS 采用混合加密机制  

HTTPS 采用共享密钥加密和公开密钥加密两者并用的混合加密机制。若密钥能够实现安全交换， 那么有可能会考虑仅使用公开密钥加密来通信。但是公开密钥加密与共享密钥加密相比，其处理速度要慢。所以应充分利用两者各自的优势， 将多种方法组合起来用于通信。在交换密钥环节使用公开密钥加密方式，之后的建立通信交换报文阶段则使用共享密钥加密方式。

![](./img/hybrid_encryption.png)

### 证明公开密钥正确性的证书  

公开密钥加密方式还是存在一些问题的。那就是无法证明公开密钥本身就是货真价实的公开密钥。 比如，正准备和某台服务器建立公开密钥加密方式下的通信时，如何证明收到的公开密钥就是原本预想的那台服务器发行的公开密钥。 或许在公开密钥传输途中，真正的公开密钥已经被攻击者替换掉了。  

为了解决上述问题，可以使用由数字证书认证机构（ CA， Certificate Authority）和其相关机关颁发的公开密钥证书。  

数字证书认证机构处于客户端与服务器双方都可信赖的第三方机构的立场上。  

- 服务器的运营人员向数字证书认证机构提出公开密钥的申请
- 数字证书认证机构在判明提出申请者的身份之后， 会对已申请的公开密钥做数字签名，然后分配这个已签名的公开密钥， 并将该公开密钥放入公钥证书后绑定在一起
- 服务器会将这份由数字证书认证机构颁发的公钥证书发送给客户端，以进行公开密钥加密方式通信。 公钥证书也可叫做数字证书或直接称为证书
- 接到证书的客户端可使用数字证书认证机构的公开密钥， 对那张证书上的数字签名进行验证， 一旦验证通过，客户端便可明确两件事：
  - 认证服务器的公开密钥的是真实有效的数字证书认证机构
  - 服务器的公开密钥是值得信赖的

认证机关的公开密钥必须安全地转交给客户端。 使用通信方式时，如何安全转交是一件很困难的事， 因此，多数浏览器开发商发布版本时，会事先在内部植入常用认证机关的公开密钥。  

![](./img/authentication.png)

### 可证明组织真实性的EV SSL证书  

证书的一个作用是用来证明作为通信一方的服务器是否规范，另外一个作用是可确认对方服务器背后运营的企业是否真实存在。 拥有该特性的证书就是 EV SSL 证书（ Extended Validation SSL Certificate）。  

EV SSL 证书是基于国际标准的认证指导方针颁发的证书。其严格规定了对运营组织是否真实的确认方针， 因此，通过认证的 Web 网站能够获得更高的认可度。  

### 用以确认客户端的客户端证书

HTTPS 中还可以使用客户端证书。以客户端证书进行客户端认证，证明服务器正在通信的对方始终是预料之内的客户端， 其作用跟服务器证书如出一辙。  

但客户端证书仍存在几处问题点：

- 证书的获取及发布：想获取证书时， 用户得自行安装客户端证书，这需要费用和一定的技术基础
- 客户端证书毕竟只能用来证明客户端实际存在， 而不能用来证明用户本人的真实有效性，也就是说，只要获得了安装有客户端证书的计算机的使用权限， 也就意味着同时拥有了客户端证书的使用权限  

### 认证机构信誉第一  

虽然存在可将证书无效化的证书吊销列表（ Certificate Revocation List， CRL）机制， 以及从客户端删除根证书颁发机构（ Root Certificate Authority， RCA）的对策， 但是距离生效还需要一段时间，而在这段时间内，到底会有多少用户的利益蒙受损失就不得而知了。  

### 由自认证机构颁发的证书称为自签名证书  

使用 OpenSSL 这套开源程序，每个人都可以构建一套属于自己的认证机构， 从而自己给自己颁发服务器证书。但该服务器证书在互联网上不可作为证书使用。  

独立构建的认证机构叫做自认证机构， 由自认证机构颁发的“无用”证书也被戏称为自签名证书。浏览器访问该服务器时， 会显示“无法确认连接安全性”或“该网站的安全证书存在问题”等警告消息。  

![](./img/Self_signed_certificate.png)

由自认证机构颁发的服务器证书之所以不起作用，是因为它无法消除伪装的可能性。   

### 中级认证机构的证书可能会变成自认证证书  

多数浏览器内预先已植入备受信赖的认证机构的证书，但也有一小部分浏览器会植入中级认证机构的证书。

对于中级认证机构颁发的服务器证书， 某些浏览器会以正规的证书来对待，可有的浏览器会当作自签名证书。  

## HTTPS 的安全通信机制  

HTTPS 的通信步骤：

![](./img/https_steps.png)

- 客户端通过发送 Client Hello 报文开始 SSL 通信。报文中包含客户端支持的 SSL 的指定版本、加密组件（ Cipher Suite）列表（所使用的加密算法及密钥长度等）
- 服务器可进行 SSL 通信时，会以 Server Hello 报文作为应答。和客户端一样，在报文中包含 SSL 版本以及加密组件。服务器的加密组件内容是从接收到的客户端加密组件内筛选出来的
- 之后服务器发送 Certificate 报文。报文中包含公开密钥证书
- 最后服务器发送 Server Hello Done 报文通知客户端，最初阶段的 SSL 握手协商部分结束
- SSL 第一次握手结束之后，客户端以 Client Key Exchange 报文作为回应。报文中包含通信加密中使用的一种被称为 Pre-master secret 的随机密码串。该报文已用步骤 3 中的公开密钥进行加密
- 接着客户端继续发送 Change Cipher Spec 报文。该报文会提示服务器，在此报文之后的通信会采用 Pre-master secret 密钥加密
- 客户端发送 Finished 报文。该报文包含连接至今全部报文的整体校验值。这次握手协商是否能够成功，要以服务器是否能够正确解密该报文作为判定标准
- 服务器同样发送 Change Cipher Spec 报文
- 服务器同样发送 Finished 报文
- 服务器和客户端的 Finished 报文交换完毕之后， SSL 连接就算建立完成。当然，通信会受到 SSL 的保护。从此处开始进行应用层协议的通信，即发送 HTTP 请求
- 应用层协议通信，即发送 HTTP 响应
- 最后由客户端断开连接。断开连接时，发送 close_notify  报文。这步之后再发送 TCP FIN 报文来关闭与 TCP 的通信

在以上流程中， 应用层发送数据时会附加一种叫做 MAC（ Message Authentication Code）的报文摘要。 MAC 能够查知报文是否遭到篡改，从而保护报文的完整性。  

![](./img/https_steps2.png)

### SSL和TLS

HTTPS 使 用 SSL（ Secure Socket Layer） 和 TLS（ Transport Layer Security）这两个协议。  

SSL 技术最初是由浏览器开发商网景通信公司率先倡导的，开发过 SSL3.0 之前的版本。  TSL 是以 SSL 为原型开发的协议，有时会统一称该协议为 SSL。当前
主流的版本是 SSL3.0 和 TLS1.0。  

### SSL速度慢吗  

HTTPS 也存在一些问题，那就是当使用 SSL 时，它的处理速度会变慢。

![](./img/https_slow.png)

SSL 的慢分两种：

- 一种是指通信慢

- 另一种是指由于大量消耗 CPU 及内存等资源，导致处理速度变慢

和使用 HTTP 相比，网络负载可能会变慢 2 到 100 倍。除去和 TCP  连接、发送 HTTP 请求-响应以外，还必须进行 SSL 通信，因此整体上处理通信量不可避免会增加。  

另一点是 SSL 必须进行加密处理。在服务器和客户端都需要进行加密和解密的运算处理。 因此从结果上讲，比起 HTTP 会更多地消耗服务器和客户端的硬件资源，导致负载增强。  

针对速度变慢这一问题， 并没有根本性的解决方案，我们会使用SSL 加速器这种（专用服务器）硬件来改善该问题。该硬件为 SSL 通信专用硬件，相对软件来讲，能够提高数倍 SSL 的计算速度。仅在 SSL 处理时发挥 SSL 加速器的功效，以分担负载。  







# 为什么要有HTTPS？

“因为HTTP不安全”。由于HTTP天生“明文”的特点，整个传输过程完全透明，任何人都能够在链路中截获、修改或者伪造请求/响应报文，数据不具有可信性。

# 什么是安全？

通常认为，如果通信过程具备了四个特性，就可以认为是“安全”的，这四个特性是：机密性、完整性，身份认证和不可否认。

## 机密性

机密性（Secrecy/Confidentiality）是指对数据的“保密”，只能由可信的人访问，对其他人是不可见的“秘密”，简单来说就是不能让不相关的人看到不该看的东西。

## 完整性

完整性（Integrity，也叫一致性）是指数据在传输过程中没有被窜改，不多也不少，“完完整整”地保持着原状。

## 身份认证

身份认证（Authentication）是指确认对方的真实身份，也就是“证明你真的是你”，保证消息只能发送给可信的人。

## 不可否认

不可否认（Non-repudiation/Undeniable），也叫不可抵赖，意思是不能否认已经发生过的行为，不能“说话不算数”“耍赖皮”。

# 什么是HTTPS？

HTTPS 默认端口号443，至于其他的什么请求-应答模式、报文结构、请求方法、URI、头字段、连接管理等等都完全沿用HTTP，没有任何新的东西。也就是说，除了协议名“http”和端口号80这两点不同，HTTPS协议在语法、语义上和HTTP完全一样，优缺点也“照单全收”（当然要除去“明文”和“不安全”）。

HTTPS  将 HTTP 下层的传输协议由TCP/IP换成了SSL/TLS，由“**HTTP over TCP/IP**”变成了“**HTTP over SSL/TLS**”，让HTTP运行在了安全的SSL/TLS协议上，收发报文不再使用Socket API，而是调用专门的安全接口。

![](./img/https.png)

# SSL/TLS

SSL即安全套接层（Secure Sockets Layer），在OSI模型中处于第5层（会话层），由网景公司于1994年发明，有v2和v3两个版本，而v1因为有严重的缺陷从未公开过。

SSL发展到v3时已经证明了它自身是一个非常好的安全通信协议，于是互联网工程组IETF在1999年把它改名为TLS（传输层安全，Transport Layer Security），正式标准化，版本号从1.0重新算起，所以TLS1.0实际上就是SSLv3.1。

目前应用的最广泛的TLS是1.2，而之前的协议（TLS1.1/1.0、SSLv3/v2）都已经被认为是不安全的，各大浏览器即将在2020年左右停止支持。

TLS由记录协议、握手协议、警告协议、变更密码规范协议、扩展协议等几个子协议组成，综合使用了对称加密、非对称加密、身份认证等许多密码学前沿技术。

# OpenSSL

说到TLS，就不能不谈到OpenSSL，它是一个著名的开源密码学程序库和工具包，几乎支持所有公开的加密算法和协议，已经成为了事实上的标准，许多应用软件都会使用它作为底层库来实现TLS功能，包括常用的Web服务器Apache、Nginx等。





