# HTTP 的缺点

## 通信安全四个特性

通常认为，如果通信过程具备了四个特性，就可以认为是“安全”的，这四个特性是：机密性、完整性，身份认证和不可否认。

- 机密性，机密性（Secrecy/Confidentiality）是指对数据的“保密”，只能由可信的人访问，对其他人是不可见的“秘密”，简单来说就是不能让不相关的人看到不该看的东西

- 完整性，完整性（Integrity，也叫一致性）是指数据在传输过程中没有被窜改，不多也不少，“完完整整”地保持着原状

- 身份认证，身份认证（Authentication）是指确认对方的真实身份，也就是“证明你真的是你”，保证消息只能发送给可信的人

- 不可否认，不可否认（Non-repudiation/Undeniable），也叫不可抵赖，意思是不能否认已经发生过的行为，不能“说话不算数”“耍赖皮”

## Http 的主要不足

-  通信使用明文（不加密），内容可能会被窃听
- 不验证通信方的身份，因此有可能遭遇伪装
- 无法证明报文的完整性，所以有可能已遭篡改

### 通信使用明文可能会被窃听  

互联网上的任何角落都存在通信内容被窃听的风险：

![](./img/wiretap.png)

防止窃听保护信息的几种对策中，最为普及的就是加密技术。加密的对象可以有：

- 通信的加密
- 内容的加密

#### 通信的加密

HTTP 协议中没有加密机制，但可以通过和 SSL（ Secure Socket Layer，安全套接层）或 TLS（ Transport Layer Security，安全层传输协议）的组合使用，加密 HTTP 的通信内容。  

用 SSL 建立安全通信线路之后，就可以在这条线路上进行 HTTP 通信了。与 SSL 组合使用的 HTTP 被称为 HTTPS（ HTTP Secure，超文本传输安全协议）或 HTTP over SSL。  

![](./img/http_over_ssl.png)

####　内容的加密

即把 HTTP 报文里所含的内容进行加密处理。  

![](./img/encryped_content.png)

为了做到有效的内容加密，前提是要求客户端和服务器同时具备加密和解密机制。 主要应用在 Web 服务中。有一点必须引起注意，由于该方式不同于 SSL 或 TLS 将整个通信线路加密处理，所以内容仍有被篡改的风险。  

### 不验证通信方的身份就可能遭遇伪装  

HTTP 协议中的请求和响应不会对通信方进行确认。也就是说存在“服务器是否就是发送请求中 URI 真正指定的主机，返回的响应是否真的返回到实际提出请求的客户端”等类似问题。  

#### 任何人都可发起请求  

在 HTTP 协议通信时，由于不存在确认通信方的处理步骤，任何人都可以发起请求。 另外，服务器只要接收到请求，不管对方是谁都会返回一个响应（但也仅限于发送端的 IP 地址和端口号没有被 Web 服务器设定限制访问的前提下）。  

![](./img/anyone_request.png)

- 无法确定请求发送至目标的 Web 服务器是否是按真实意图返回响应的那台服务器。有可能是已伪装的 Web 服务器
- 无法确定响应返回到的客户端是否是按真实意图接收响应的那个客户端。有可能是已伪装的客户端
- 无法确定正在通信的对方是否具备访问权限。因为某些 Web 服务器上保存着重要的信息，只想发给特定用户通信的权限  
- 无法判定请求是来自何方、出自谁手
- 即使是无意义的请求也会照单全收。无法阻止海量请求下的 DoS 攻击（Denial of Service，拒绝服务攻击）  

#### 查明对手的证书

虽然使用 HTTP 协议无法确定通信方，但如果使用 SSL 则可以。SSL 不仅提供加密处理， 而且还使用了一种被称为证书的手段，可用于确定方。  

证书由值得信任的第三方机构颁发， 用以证明服务器和客户端是实际存在的。  

![](./img/certificate.png)

### 无法证明报文完整性，可能已遭篡改  

所谓完整性是指信息的准确度。若无法证明其完整性，通常也就意味着无法判断信息是否准确。  

#### 接收到的内容可能有误  

没有任何办法确认，发出的请求/响应和接收到的请求/响应是前后相同的。  

![](./img/changed.png)

像这样，请求或响应在传输途中，遭攻击者拦截并篡改内容的攻击称为中间人攻击（ Man-in-the-Middle attack， MITM）。  

![](./img/mitm.png)

#### 如何防止篡改  

虽然有使用 HTTP 协议确定报文完整性的方法，但并不便捷、可靠。其中常用的是 MD5 和 SHA-1 等散列值校验的方法，以及用来确认文件的数字签名方法。  

# HTTPS  

**HTTP+ 加密 + 认证 + 完整性保护 = HTTPS**，把添加了加密及认证机制的 HTTP 称为 HTTPS（ HTTP Secure）。  

![](./img/http_secure.png)

## HTTPS 是身披 SSL 外壳的 HTTP  

HTTPS 并非是应用层的一种新协议。只是 HTTP 通信接口部分用 SSL（ Secure Socket Layer）和 TLS（ Transport Layer Security）协议代替而已。  

![](./img/https.png)

在采用 SSL 后， HTTP 就拥有了 HTTPS 的加密、证书和完整性保护这些功能。  

SSL 是独立于 HTTP 的协议，所以不光是 HTTP 协议，其他运行在应用层的 SMTP 和 Telnet 等协议均可配合 SSL 协议使用。  

## 相互交换密钥的公开密钥加密技术

SSL 采用一种叫做公开密钥加密（ Public-key cryptography）的加密处理方式。近代的加密方法中加密算法是公开的， 而密钥却是保密的。通过这
种方式得以保持加密方法的安全性。

加密和解密都会用到密钥。 没有密钥就无法对密码解密，反过来说，任何人只要持有密钥就能解密了。 如果密钥被攻击者获得，那加密也就失去了意义。  

### 共享密钥加密的困境  

加密和解密同用一个密钥的方式称为共享密钥加密（ Common key crypto system），也被叫做对称密钥加密。  

以共享密钥方式加密时必须将密钥也发给对方。  在互联网上转发密钥时，如果通信被监听那么密钥就可会落入攻击者之手， 同时也就失去了加密的意义。另外还得设法安全地保管接收到的密钥。  

![](./img/symmetric_encryption.png)

### 使用两把密钥的公开密钥加密  

公开密钥加密使用一对非对称的密钥。 一把叫做私有密钥（ privatekey），另一把叫做公开密钥（ public key）。私有密钥不能让其他任何人知道，而公开密钥则可以随意发布，任何人都可以获得。  

使用公开密钥加密方式， 发送密文的一方使用对方的公开密钥进行加密处理，对方收到被加密的信息后，再使用自己的私有密钥进行解密。 利用这种方式， 不需要发送用来解密的私有密钥，也不必担心密钥被攻击者窃听而盗走。  

要想根据密文和公开密钥，恢复到信息原文是异常困难的，因为解密过程就是在对离散对数进行求值， 这并非轻而易举就能办到。退一步讲，如果能对一个非常大的整数做到快速地因式分解，那么密码破解还是存在希望的。但就目前的技术来看是不太现实的。  

![](./img/public_private_key.png)

### HTTPS 采用混合加密机制  

HTTPS 采用共享密钥加密和公开密钥加密两者并用的混合加密机制。若密钥能够实现安全交换， 那么有可能会考虑仅使用公开密钥加密来通信。但是公开密钥加密与共享密钥加密相比，其处理速度要慢。所以应充分利用两者各自的优势， 将多种方法组合起来用于通信。在交换密钥环节使用公开密钥加密方式，之后的建立通信交换报文阶段则使用共享密钥加密方式。

![](./img/hybrid_encryption.png)

### 证明公开密钥正确性的证书  

公开密钥加密方式还是存在一些问题的。那就是无法证明公开密钥本身就是货真价实的公开密钥。 比如，正准备和某台服务器建立公开密钥加密方式下的通信时，如何证明收到的公开密钥就是原本预想的那台服务器发行的公开密钥。 或许在公开密钥传输途中，真正的公开密钥已经被攻击者替换掉了。  

为了解决上述问题，可以使用由数字证书认证机构（ CA， Certificate Authority）和其相关机关颁发的公开密钥证书。  

数字证书认证机构处于客户端与服务器双方都可信赖的第三方机构的立场上。  

- 服务器的运营人员向数字证书认证机构提出公开密钥的申请
- 数字证书认证机构在判明提出申请者的身份之后， 会对已申请的公开密钥做数字签名，然后分配这个已签名的公开密钥， 并将该公开密钥放入公钥证书后绑定在一起
- 服务器会将这份由数字证书认证机构颁发的公钥证书发送给客户端，以进行公开密钥加密方式通信。 公钥证书也可叫做数字证书或直接称为证书
- 接到证书的客户端可使用数字证书认证机构的公开密钥， 对那张证书上的数字签名进行验证， 一旦验证通过，客户端便可明确两件事：
  - 认证服务器的公开密钥的是真实有效的数字证书认证机构
  - 服务器的公开密钥是值得信赖的

认证机关的公开密钥必须安全地转交给客户端。 使用通信方式时，如何安全转交是一件很困难的事， 因此，多数浏览器开发商发布版本时，会事先在内部植入常用认证机关的公开密钥。  

![](./img/authentication.png)

### 可证明组织真实性的EV SSL证书  

证书的一个作用是用来证明作为通信一方的服务器是否规范，另外一个作用是可确认对方服务器背后运营的企业是否真实存在。 拥有该特性的证书就是 EV SSL 证书（ Extended Validation SSL Certificate）。  

EV SSL 证书是基于国际标准的认证指导方针颁发的证书。其严格规定了对运营组织是否真实的确认方针， 因此，通过认证的 Web 网站能够获得更高的认可度。  

### 用以确认客户端的客户端证书

HTTPS 中还可以使用客户端证书。以客户端证书进行客户端认证，证明服务器正在通信的对方始终是预料之内的客户端， 其作用跟服务器证书如出一辙。  

但客户端证书仍存在几处问题点：

- 证书的获取及发布：想获取证书时， 用户得自行安装客户端证书，这需要费用和一定的技术基础
- 客户端证书毕竟只能用来证明客户端实际存在， 而不能用来证明用户本人的真实有效性，也就是说，只要获得了安装有客户端证书的计算机的使用权限， 也就意味着同时拥有了客户端证书的使用权限  

### 认证机构信誉第一  

虽然存在可将证书无效化的证书吊销列表（ Certificate Revocation List， CRL）机制， 以及从客户端删除根证书颁发机构（ Root Certificate Authority， RCA）的对策， 但是距离生效还需要一段时间，而在这段时间内，到底会有多少用户的利益蒙受损失就不得而知了。  

### 由自认证机构颁发的证书称为自签名证书  

使用 OpenSSL 这套开源程序，每个人都可以构建一套属于自己的认证机构， 从而自己给自己颁发服务器证书。但该服务器证书在互联网上不可作为证书使用。  

独立构建的认证机构叫做自认证机构， 由自认证机构颁发的“无用”证书也被戏称为自签名证书。浏览器访问该服务器时， 会显示“无法确认连接安全性”或“该网站的安全证书存在问题”等警告消息。  

![](./img/Self_signed_certificate.png)

由自认证机构颁发的服务器证书之所以不起作用，是因为它无法消除伪装的可能性。   

### 中级认证机构的证书可能会变成自认证证书  

多数浏览器内预先已植入备受信赖的认证机构的证书，但也有一小部分浏览器会植入中级认证机构的证书。

对于中级认证机构颁发的服务器证书， 某些浏览器会以正规的证书来对待，可有的浏览器会当作自签名证书。  

## HTTPS 的安全通信机制  

HTTPS 的通信步骤：

![](./img/https_steps.png)

- 客户端通过发送 Client Hello 报文开始 SSL 通信。报文中包含客户端支持的 SSL 的指定版本、加密组件（ Cipher Suite）列表（所使用的加密算法及密钥长度等）
- 服务器可进行 SSL 通信时，会以 Server Hello 报文作为应答。和客户端一样，在报文中包含 SSL 版本以及加密组件。服务器的加密组件内容是从接收到的客户端加密组件内筛选出来的
- 之后服务器发送 Certificate 报文。报文中包含公开密钥证书
- 最后服务器发送 Server Hello Done 报文通知客户端，最初阶段的 SSL 握手协商部分结束
- SSL 第一次握手结束之后，客户端以 Client Key Exchange 报文作为回应。报文中包含通信加密中使用的一种被称为 Pre-master secret 的随机密码串。该报文已用步骤 3 中的公开密钥进行加密
- 接着客户端继续发送 Change Cipher Spec 报文。该报文会提示服务器，在此报文之后的通信会采用 Pre-master secret 密钥加密
- 客户端发送 Finished 报文。该报文包含连接至今全部报文的整体校验值。这次握手协商是否能够成功，要以服务器是否能够正确解密该报文作为判定标准
- 服务器同样发送 Change Cipher Spec 报文
- 服务器同样发送 Finished 报文
- 服务器和客户端的 Finished 报文交换完毕之后， SSL 连接就算建立完成。当然，通信会受到 SSL 的保护。从此处开始进行应用层协议的通信，即发送 HTTP 请求
- 应用层协议通信，即发送 HTTP 响应
- 最后由客户端断开连接。断开连接时，发送 close_notify  报文。这步之后再发送 TCP FIN 报文来关闭与 TCP 的通信

在以上流程中， 应用层发送数据时会附加一种叫做 MAC（ Message Authentication Code）的报文摘要。 MAC 能够查知报文是否遭到篡改，从而保护报文的完整性。  

![](./img/https_steps2.png)

### SSL和TLS

HTTPS 使 用 SSL（ Secure Socket Layer） 和 TLS（ Transport Layer Security）这两个协议。  

SSL 技术最初是由浏览器开发商网景通信公司率先倡导的，开发过 SSL3.0 之前的版本。  TSL 是以 SSL 为原型开发的协议，有时会统一称该协议为 SSL。当前
主流的版本是 SSL3.0 和 TLS1.0。  

### SSL速度慢吗  

HTTPS 也存在一些问题，那就是当使用 SSL 时，它的处理速度会变慢。

![](./img/https_slow.png)

SSL 的慢分两种：

- 一种是指通信慢

- 另一种是指由于大量消耗 CPU 及内存等资源，导致处理速度变慢

和使用 HTTP 相比，网络负载可能会变慢 2 到 100 倍。除去和 TCP  连接、发送 HTTP 请求-响应以外，还必须进行 SSL 通信，因此整体上处理通信量不可避免会增加。  

另一点是 SSL 必须进行加密处理。在服务器和客户端都需要进行加密和解密的运算处理。 因此从结果上讲，比起 HTTP 会更多地消耗服务器和客户端的硬件资源，导致负载增强。  

针对速度变慢这一问题， 并没有根本性的解决方案，我们会使用SSL 加速器这种（专用服务器）硬件来改善该问题。该硬件为 SSL 通信专用硬件，相对软件来讲，能够提高数倍 SSL 的计算速度。仅在 SSL 处理时发挥 SSL 加速器的功效，以分担负载。  





HTTPS 默认端口号443，至于其他的什么请求-应答模式、报文结构、请求方法、URI、头字段、连接管理等等都完全沿用HTTP，没有任何新的东西。也就是说，除了协议名“http”和端口号80这两点不同，HTTPS协议在语法、语义上和HTTP完全一样，优缺点也“照单全收”（当然要除去“明文”和“不安全”）。

HTTPS  将 HTTP 下层的传输协议由TCP/IP换成了SSL/TLS，由“**HTTP over TCP/IP**”变成了“**HTTP over SSL/TLS**”，让HTTP运行在了安全的SSL/TLS协议上，收发报文不再使用Socket API，而是调用专门的安全接口。

![](./img/https.png)

# TLS 1.2

## TLS 协议的组成

TLS包含几个子协议，你也可以理解为它是由几个不同职责的模块组成，比较常用的有记录协议、警报协议、握手协议、变更密码规范协议等：

- 记录协议（Record Protocol）规定了 TLS 收发数据的基本单位：记录（record）。它有点像是 TCP 里的 segment，所有的其他子协议都需要通过记录协议发出。但多个记录数据可以在一个 TCP 包里一次性发出，也并不需要像 TCP 那样返回 ACK
- 警报协议（Alert Protocol）的职责是向对方发出警报信息，有点像是 HTTP 协议里的状态码。比如，protocol_version 就是不支持旧版本，bad_certificate 就是证书有问题，收到警报后另一方可以选择继续，也可以立即终止连接
- 握手协议（Handshake Protocol）是 TLS 里最复杂的子协议，要比 TCP 的 SYN/ACK 复杂的多，浏览器和服务器会在握手过程中协商 TLS 版本号、随机数、密码套件等信息，然后交换证书和密钥参数，最终双方协商得到会话密钥，用于后续的混合加密系统
- 变更密码规范协议（Change Cipher Spec Protocol），它非常简单，就是一个“通知”，告诉对方，后续的数据都将使用加密保护。那么反过来，在它之前，数据都是明文的

![](./img/tls_handshake.png)

## ECDHE 握手过程

![](./img/ECDHE.png)

![](./img/ECDHE_connection.png)

在TCP建立连接之后，浏览器会首先发一个“Client Hello”消息，也就是跟服务器“打招呼”。里面有客户端的版本号、支持的密码套件，还有一个随机数（Client Random），用于后续生成会话密钥。

![](./img/client_hello.png)

服务器收到“Client Hello”后，会返回一个“Server Hello”消息。把版本号对一下，也给出一个随机数（Server Random），然后从客户端的列表里选一个作为本次通信使用的密码套件。

![](./img/server_hello.png)

接下来是一个关键的操作，因为服务器选择了ECDHE算法，所以它会在证书后发送“Server Key Exchange”消息，里面是椭圆曲线的公钥（Server Params），用来实现密钥交换算法，再加上自己的私钥签名认证。

![](./img/server_key_exchange.png)

之后是“Server Hello Done”消息：

![](./img/server_hello_done.png)

这样第一个消息往返就结束了（两个TCP包），结果是客户端和服务器通过明文共享了三个信息：Client Random、Server Random和Server Params。之后开始走证书链逐级验证，确认证书的真实性，再用证书公钥验证签名，就确认了服务器的身份。

然后，客户端按照密码套件的要求，也生成一个椭圆曲线的公钥（Client Params），用“Client Key Exchange”消息发给服务器。

![](./img/client_key_exchange.png)

现在客户端和服务器手里都拿到了密钥交换算法的两个参数（Client Params、Server Params），就用ECDHE算法一阵算，算出了一个新的东西，叫“Pre-Master”，其实也是一个随机数。算法可以保证即使黑客截获了之前的参数，也是绝对算不出这个随机数的。现在客户端和服务器手里有了三个随机数：Client Random、Server Random 和 Pre-Master。用这三个作为原始材料，就可以生成用于加密会话的主密钥，叫“Master Secret”。而黑客因为拿不到“Pre-Master”，所以也就得不到主密钥。为了保证真正的“完全随机”“不可预测”，把三个不可靠的随机数混合起来，那么“随机”的程度就非常高了，足够让黑客难以猜测。

有了主密钥和派生的会话密钥，握手就快结束了。客户端发一个 “Change Cipher Spec”，然后再发一个 “Finished” 消息，把之前所有发送的数据做个摘要，再加密一下，让服务器做个验证。服务器也是同样的操作，发 “Change Cipher Spec” 和 “Finished” 消息，双方都验证加密解密 OK，握手正式结束，后面就收发被加密的HTTP 请求和响应了。

## RSA握手过程

刚才说的其实是如今主流的 TLS 握手过程，这与传统的握手有两点不同：

- 第一个，使用 ECDHE 实现密钥交换，而不是 RSA，所以会在服务器端发出“Server Key Exchange”消息
- 第二个，因为使用了 ECDHE，客户端可以不用等到服务器发回 “Finished” 确认握手完毕，立即就发出 HTTP 报文，省去了一个消息往返的时间浪费。这个叫 “TLS False Start”，意思就是“抢跑”，和 “TCP Fast Open” 有点像，都是不等连接完全建立就提前发应用数据，提高传输的效率

传统的RSA密钥交换：

![](./img/rsa.png)

# HTTPS 的优化

HTTPS 连接大致上可以划分为两个部分：

- 第一个是建立连接时的非对称加密握手
- 第二个是握手后的对称加密报文传输

由于目前流行的 AES、ChaCha20 性能都很好，还有硬件优化，报文传输的性能损耗可以说是非常地小，小到几乎可以忽略不计了。所以，通常所说的“HTTPS连接慢”指的就是刚开始建立连接的那段时间。

在TCP建连之后，正式数据传输之前，HTTPS 比 HTTP 增加了一个 TLS 握手的步骤，这个步骤最长可以花费两个消息往返，也就是 2-RTT。而且在握手消息的网络耗时之外，还会有其他的一些“隐形”消耗，比如：

- 产生用于密钥交换的临时公私钥对（ECDHE）
- 验证证书时访问CA获取CRL或者OCSP
- 非对称加密解密处理“Pre-Master”

在最差的情况下，也就是不做任何的优化措施，HTTPS 建立连接可能会比HTTP慢上几百毫秒甚至几秒，这其中既有网络耗时，也有计算耗时。但是现在已经有了很多行之有效的 HTTPS 优化手段，运用得好可以把连接的额外耗时降低到几十毫秒甚至是“零”。

![](./img/https_slow_connection.png)

## 硬件优化

HTTPS 连接是计算密集型，而不是 I/O 密集型。所以，如果你花大价钱去买网卡、带宽、SSD存储就是“南辕北辙”了，起不到优化的效果。

- 可以选择更快的CPU，最好还内建 AES 优化，这样即可以加速握手，也可以加速传输
- 可以选择“SSL加速卡”，加解密时调用它的API，让专门的硬件来做非对称加解密，分担CPU的计算压力。不过“SSL加速卡”也有一些缺点，比如升级慢、支持算法有限，不能灵活定制解决方案等
- “SSL加速服务器”，用专门的服务器集群来彻底“卸载”TLS握手时的加密解密计算，性能自然要比单纯的“加速卡”要强大的多

## 软件优化

软件方面的优化还可以再分成两部分：一个是软件升级，一个是协议优化。

- 软件升级实施起来比较简单，就是把现在正在使用的软件尽量升级到最新版本，比如把 Linux 内核由 2.x 升级到 4.x，把 Nginx 由 1.6 升级到 1.16，把OpenSSL 由 1.0.1 升级到 1.1.0/1.1.1。由于这些软件在更新版本的时候都会做性能优化、修复错误，只要运维能够主动配合，这种软件优化是最容易做的，也是最容易达成优化效果的
- 但对于很多大中型公司来说，硬件升级或软件升级都是个棘手的问题，有成千上万台各种型号的机器遍布各个机房，逐一升级不仅需要大量人手，而且有较高的风险，可能会影响正常的线上服务。所以，在软硬件升级都不可行的情况下，我们最常用的优化方式就是在现有的环境下挖掘协议自身的潜力

## 协议优化

如果有可能，应当尽量采用 TLS1.3，它大幅度简化了握手的过程，完全握手只要 1-RTT，而且更加安全。

如果暂时不能升级到1.3，只能用1.2，那么握手时使用的密钥交换协议应当尽量选用椭圆曲线的 ECDHE 算法。它不仅运算速度快，安全性高，还支持“False Start”，能够把握手的消息往返由 2-RTT 减少到 1-RTT，达到与 TLS1.3 类似的效果。

另外，椭圆曲线也要选择高性能的曲线，最好是 x25519，次优选择是 P-256。对称加密算法方面，也可以选用 “AES_128_GCM”，它能比“AES_256_GCM”略快一点点。

## 证书优化

除了密钥交换，握手过程中的证书验证也是一个比较耗时的操作，服务器需要把自己的证书链全发给客户端，然后客户端接收后再逐一验证。

这里就有两个优化点，一个是证书传输，一个是证书验证。

服务器的证书可以选择椭圆曲线（ECDSA）证书而不是RSA证书，因为224位的ECC相当于2048位的RSA，所以椭圆曲线证书的“个头”要比RSA小很多，即能够节约带宽也能减少客户端的运算量，可谓“一举两得”。

客户端的证书验证其实是个很复杂的操作，除了要公钥解密验证多个证书签名外，因为证书还有可能会被撤销失效，客户端有时还会再去访问CA，下载CRL或者OCSP数据，这又会产生DNS查询、建立连接、收发数据等一系列网络通信，增加好几个RTT。

CRL（Certificate revocation list，证书吊销列表）由CA定期发布，里面是所有被撤销信任的证书序号，查询这个列表就可以知道证书是否有效。但 CRL 因为是“定期”发布，就有“时间窗口”的安全隐患，而且随着吊销证书的增多，列表会越来越大，一个 CRL 经常会上MB。想象一下，每次需要预先下载几 M 的“无用数据”才能连接网站，实用性实在是太低了。所以，现在 CRL 基本上不用了，取而代之的是 OCSP（在线证书状态协议，Online Certificate Status Protocol），向 CA 发送查询请求，让 CA 返回证书的有效状态。

但 OCSP 也要多出一次网络请求的消耗，而且还依赖于 CA 服务器，如果 CA 服务器很忙，那响应延迟也是等不起的。于是又出来了一个“补丁”，叫“OCSP Stapling”（OCSP装订），它可以让服务器预先访问 CA 获取 OCSP 响应，然后在握手时随着证书一起发给客户端，免去了客户端连接 CA 服务器查询的时间。

## 会话复用

HTTPS 建立连接的过程：先是 TCP 三次握手，然后是 TLS一次握手。这后一次握手的重点是算出主密钥“Master Secret”，而主密钥每次连接都要重新计算，未免有点太浪费了，如果能够把“辛辛苦苦”算出来的主密钥缓存一下“重用”。这种做法就叫“会话复用”（TLS session resumption），和 HTTP Cache 一样，也是提高HTTPS性能的“大杀器”，被浏览器和服务器广泛应用。

会话复用分两种，第一种叫“Session ID”，就是客户端和服务器首次连接后各自保存一个会话的ID号，内存里存储主密钥和其他相关的信息。当客户端再次连接时发一个ID过来，服务器就在内存里找，找到就直接用主密钥恢复会话状态，跳过证书验证和密钥交换，只用一个消息往返就可以建立安全通信。

服务器在“ServerHello”消息后直接发送了“Change Cipher Spec”和“Finished”消息，复用会话完成了握手：

![](./img/session_reuse.png)

## 会话票证

“Session ID” 是最早出现的会话复用技术，也是应用最广的，但它也有缺点，服务器必须保存每一个客户端的会话数据，对于拥有百万、千万级别用户的网站来说存储量就成了大问题，加重了服务器的负担。于是，又出现了第二种 “Session Ticket” 方案。

它有点类似 HTTP 的 Cookie，存储的责任由服务器转移到了客户端，服务器加密会话信息，用 “New Session Ticket” 消息发给客户端，让客户端保存。重连的时候，客户端使用扩展 “session_ticket” 发送 “Ticket” 而不是 “Session ID”，服务器解密后验证有效期，就可以恢复会话，开始加密通信。

不过 “Session Ticket” 方案需要使用一个固定的密钥文件（ticket_key）来加密 Ticket，为了防止密钥被破解，保证“前向安全”，密钥文件需要定期轮换，比如设置为一小时或者一天。

## 预共享密钥

“False Start”“Session ID”“Session Ticket ”等方式只能实现 1-RTT，而 TLS1.3 更进一步实现了 “0-RTT”，原理和 “Session Ticket” 差不多，但在发送 Ticket 的同时会带上应用数据（Early Data），免去了 1.2 里的服务器确认步骤，这种方式叫 “Pre-shared Key”，简称为“PSK”。

![](./img/psk.png)

但 “PSK” 也不是完美的，它为了追求效率而牺牲了一点安全性，容易受到“重放攻击”（Replay attack）的威胁。黑客可以截获 “PSK” 的数据，像复读机那样反复向服务器发送。解决的办法是只允许安全的 GET/HEAD 方法，在消息里加入时间戳、“nonce” 验证，或者“一次性票证”限制重放。



